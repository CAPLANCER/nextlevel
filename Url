import pdfplumber
import os
import re
import pandas as pd
from datetime import datetime
import sys

# ==========================================
# Helper Functions for Formatting
# ==========================================

def parse_duration_to_seconds(duration_str):
    try:
        d_str = str(duration_str).strip()
        if ':' in d_str:
            parts = list(map(int, d_str.split(':')))
            if len(parts) == 2: # MM:SS
                return parts[0] * 60 + parts[1]
            elif len(parts) == 3: # HH:MM:SS
                return parts[0] * 3600 + parts[1] * 60 + parts[2]
        elif d_str.isdigit():
            return int(d_str)
    except:
        return 0
    return 0

def format_date(d_str):
    formats = ["%d-%b-%Y", "%d/%b/%Y", "%d/%m/%y"]
    for fmt in formats:
        try:
            return datetime.strptime(d_str, fmt).strftime("%d-%m-%Y")
        except ValueError:
            continue
    return d_str

def format_time(t_str):
    try:
        return datetime.strptime(t_str, "%H:%M:%S").strftime("%I:%M %p")
    except ValueError:
        return t_str

def format_duration(d_str):
    if str(d_str).isdigit():
        seconds = int(d_str)
        m, s = divmod(seconds, 60)
        return f"{m:02d}:{s:02d}"
    
    if ':' in str(d_str):
        try:
            parts = str(d_str).split(':')
            if len(parts) == 2:
                return f"{int(parts[0]):02d}:{int(parts[1]):02d}"
            elif len(parts) == 3:
                total_sec = int(parts[0])*3600 + int(parts[1])*60 + int(parts[2])
                m, s = divmod(total_sec, 60)
                return f"{m:02d}:{s:02d}"
        except:
            pass
    return str(d_str)

# ==========================================
# Main Extraction Logic
# ==========================================

def process_single_pdf(pdf_path, output_excel_path):
    if not os.path.exists(pdf_path):
        print(f"Error: Input PDF file '{pdf_path}' does not exist.")
        return

    # Ensure output directory exists
    output_dir = os.path.dirname(output_excel_path)
    if output_dir and not os.path.exists(output_dir):
        try:
            os.makedirs(output_dir)
            print(f"Created output directory: {output_dir}")
        except Exception as e:
            print(f"Error creating output directory: {e}")
            return

    print(f"--- Processing {os.path.basename(pdf_path)} ---")

    # Regex Patterns (same as process_call_logs.py)
    jio_pattern = re.compile(r'(\d{2}-[A-Z]{3}-\d{4})\s+(\d{2}:\d{2}:\d{2})\s+(\d+)\s+(\d+)\s+')
    # Updated Airtel pattern to handle HH:MM:SS (0-2 groups of :digits) and ANY number length (\d+)
    airtel_pattern = re.compile(r'(\d{2}/[A-Z]{3}/\d{4})\s+(\d{2}:\d{2}:\d{2})\s+(\d+)\s+(\d+(?::\d+){0,2})\s+')
    # Updated Vi pattern to handle optional text between Time and Number (e.g. Roaming Partner)
    vi_pattern = re.compile(r'(\d{2}/\d{2}/\d{2})-(\d{2}:\d{2}:\d{2})(?:.*?)?\s+(\d+)\s+(\d+:\d{2})\s+')

    provider = "Unknown"
    user_name = "Unknown"
    current_file_calls = []

    try:
        with pdfplumber.open(pdf_path) as pdf:
            # 1. Identify Provider
            if len(pdf.pages) > 0:
                first_page_text = pdf.pages[0].extract_text() or ""
                
                if "Jio" in first_page_text: provider = "Jio"
                elif "Airtel" in first_page_text: provider = "Airtel"
                elif "Vi" in first_page_text or "Vodafone" in first_page_text: provider = "Vi"
                
                # Updated Regex: Optional period (Mr. Name OR Mr Name)
                name_match = re.search(r'(?:Mr\.?|Ms\.?|Mrs\.?)\s+([A-Za-z\s]+)', first_page_text)
                if not name_match:
                        name_match = re.search(r'Name\s*[:]\s*([A-Za-z\s]+)', first_page_text)
                
                if name_match:
                    user_name = name_match.group(1).strip()
                    user_name = user_name.replace("Jio Number", "").replace("Your Plan", "").replace("Vi No", "").replace("\n", " ").strip()
            
            print(f"  > Provider: {provider}, User: {user_name}")

            # 2. Extract Calls
            current_type = "Voice" # Default to Voice if no header found
            
            for page in pdf.pages:
                text = page.extract_text()
                if not text: continue
                
                lines = text.split('\n')
                for line in lines:
                    # Detect Section Headers
                    line_lower = line.lower()
                    if "total" not in line_lower:
                        if any(k in line_lower for k in ["voice", "roaming", "outgoing", "incoming", "call"]):
                            current_type = "Voice"
                        elif any(k in line_lower for k in ["sms", "message"]):
                            current_type = "SMS"
                        elif any(k in line_lower for k in ["data", "internet"]):
                            current_type = "Data"

                    # Skip Data and SMS sections - REMOVED for robust 2-column handling
                    # We process all lines and filter SMS by duration format later.

                    # Universal findall logic for all providers
                    matches = []
                    if provider == "Vi":
                        matches = vi_pattern.findall(line)
                    elif provider == "Jio":
                        matches = jio_pattern.findall(line)
                    elif provider == "Airtel":
                        matches = airtel_pattern.findall(line)
                    
                    for match in matches:
                        if len(match) == 4:
                            raw_date, raw_time, number, raw_duration = match
                        else:
                            continue

                        # Filter logic for Airtel:
                        # Voice calls have duration like "00:42" (contains :)
                        # SMS logs have duration like "1" (no :)
                        if provider == "Airtel":
                            if ':' not in raw_duration and raw_duration.strip() == '1':
                                continue # Skip SMS

                        seconds = parse_duration_to_seconds(raw_duration)
                        
                        # Filter logic:
                        # Calls: Must be > 0 seconds
                        
                        if seconds > 0 and len(number) > 5:
                            current_file_calls.append({
                                "Username": user_name,
                                "Date": format_date(raw_date),
                                "Time": format_time(raw_time),
                                "Number": number,
                                "Duration": format_duration(raw_duration)
                            })

        # 3. Save to Output File
        if current_file_calls:
            df = pd.DataFrame(current_file_calls)
            df = df[["Username", "Date", "Time", "Number", "Duration"]]
            
            df.to_excel(output_excel_path, index=False)
            print(f"  > Saved {len(df)} records to: {output_excel_path}")
        else:
            print(f"  > No calls extracted.")

    except Exception as e:
        print(f"  > Error: {e}")
    print("")

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: python single_pdf_extractor.py <input_pdf_path> <output_excel_path>")
    else:
        input_pdf_path = sys.argv[1]
        output_excel_path = sys.argv[2]
        process_single_pdf(input_pdf_path, output_excel_path)
